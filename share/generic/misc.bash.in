#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

###############################################################################
## @brief a line utility, it is missing on some systems
## 
## @param stdin     stream to read from
## 
## @return 0 for success
## @retval stdout   first line read from stdin
##
###############################################################################

myline () {

    local line
    
    IFS= read -r line && printf '%s\n' "$line"
    
}

###############################################################################
## @brief function to print an error msg
## 
## @param ...   mesages to print
##
## @return the status of the the last cmd before printerror was called
## @retval stderr   the complete error message
##
## @details
## cmd || printerror [ msg ] ; return
##
###############################################################################

printerror () {

    ecode=$?
    
    echo "ERROR: ${@:1} ${FUNCNAME[1]} ${BASH_SOURCE[1]}:${BASH_LINENO[0]}" 1>&2

    return $ecode
}

###############################################################################
## @brief function to mk a temp dir in ramdisk if the optgion is set or regular
##        temp dir if not
## 
## @return 0 for success 1 for failure
## @retval stdout   the full path to the new temp dir
##
## @details
## global vars
## @param ramdisk   if set the dir will be made here
## @param tmpdir    the dir will be made here if ramdisk not set
## @param 
##
###############################################################################

mkramtmpdir () {
    
    if [ -n "$ramdisk" ]
    then
        mktemp -d -p "${ramdisk}" "${dsname}XXXXXXXXXX" || { printerror ; return; }
    else
        mktemp -d -p "${tmpdir}"  "${dsname}XXXXXXXXXX" || { printerror ; return; }
    fi
}
    
###############################################################################
## @brief function to test for true
##
## @param value     the value to test
## @param default   the default return value if no match
##
## @return 0 for true, 1 for false
##
## @details
## case insensitive matching of true/ false / yes / no / 0 (false)/ 1 (true)
##
###############################################################################

istrue () {
    
   case "$1" in
        [nN][oO])
            false
            ;;
        [yY][eE][sS])
            true
            ;;
        [fF][aA][lL][sS][eE])
            false
            ;;
        [tT][rR][uU][eE])
            true
            ;;
        0)
            false
            ;;
        1)
            true
            ;;
        *)
            ##### if there is a second numeric arg return it by itself,#####
            ##### otherwise return the default of false #####
            
            if [ -n "$2" ]
            then
                return $2
            else
                false
            fi
            ;;
    esac
    
}

###############################################################################
## @brief to remove dupe /'s from a path
##
## @param path  the path to fix
##
## @return 0 for success
##
## @retval stdout the path with missing /'s removed
##
###############################################################################

fixpath () {

    sed -r 's|[/]+|/|g' <<<"$1"
}

###############################################################################
## @brief function to get the extent of the ds
##
## @param ts    the timestamp of the dataset
##
## @return 0 for success
##
## @retval stdout the extent "west south east north"
##
## @details
## global vars
## @param outdir      the datasets output dir
## @param dsname      the name of the dataset
##
###############################################################################

getextent () {
    ts="$1"

    ogrinfo -so -al "${outdir}/${dsname}${ts}.shp" |\
     grep Extent: |\
     sed -e 's/) - (/ /' -e 's/Extent: (//' -e 's/,//g' -e 's/)//'
}

getextent2 () {
    file="$1"

    ogrinfo -so -al "${file}" |\
     grep Extent: |\
     sed -e 's/) - (/ /' -e 's/Extent: (//' -e 's/,//g' -e 's/)//'
}

###############################################################################
## @brief min a b for floats
##
## @param a     first value
## @param b     second value
##
## @return 0 for success, 1 for failure
## 
## @retval stdout the smallest value
##
###############################################################################

fmin () {
    
    bc << EOF
scale=20;
define min(a,b) {
    if (a < b) return a;
    return b;
}
min($1, $2)
EOF
}

###############################################################################
## @brief max a b for floats
##
## @param a     first value
## @param b     second value
##
## @return 0 for success, 1 for failure
## 
## @retval stdout the largest value
##
###############################################################################

fmax () {
    
    bc << EOF
scale=20;
define max(a,b) {
    if (a > b) return a;
    return b;
}
max($1, $2)
EOF
}

###############################################################################
## @brief frontend to bc for calcing floats
##
## @param ...   the calculation to perform
##
## @return 0 for success, 1 for failure
## 
## @retval stdout the calculation result
##
###############################################################################

fcalc () {

    if [[ $# -gt 0 ]]
    then
        echo "scale=20; $*" | bc -q 2>/dev/null
    fi
}
    
###############################################################################
## @brief frontend to bc for compareing floats
##
## @param ...   the comparison "1.0 < 30"
##
## @return 0 for true, 1 for false
## 
###############################################################################

fcmp () {

    local cond=0
    if [[ $# -gt 0 ]]
    then
        cond=$(echo "$*" | bc -q 2>/dev/null)
        if [[ -z "$cond" ]]
        then
            cond=0
        fi
        if [[ "$cond" != 0  &&  "$cond" != 1 ]]
        then
            cond=0
        fi
    fi
    local res=$((cond == 0))
    return $res
}

###############################################################################
## @brief convert sci notation to dec
##
## @param in    the scientific notation
##
## @return 0 for true, 1 for false
##
## @retval stdout the numper in decimal
##
###############################################################################

fsci2dec () {
    
    fcalc $(sed 's/e[+]*/*10^/g' <<< "$1")
}
    
###############################################################################
## @brief function to get a ts from a lftp command
##
## @param stdin  the lines from the mirror file
##
## @return 0 for true, 1 for false
##
## @retval stdout the timestamps "20010520"
##
###############################################################################


dodate () {
    RX_YMD='\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)';
    RX_MDY='\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{4\}\)';
    RX_YDJ='\([0-9]\{4\}\)\([0-9]\{3\}\)';

    Months=(january february march april may june july august september
            october november december jan feb mar apr jun jul aug sep sept oct
            nov dec);

    RX_LM='\(';

    needor=0;
    for m in "${Months[@]}" 
    do
        if istrue $needor
        then
            RX_LM="$RX_LM"'\|'
        else
            needor=1
        fi

        while read c
        do
            RX_LM="${RX_LM}[$(tr "[a-z]" "[A-Z]" <<<"$c")${c}]"
        done < <(fold -w1 <<<"$m")
        
    done;
    RX_LM="$RX_LM"'\)';

    RX_MLD="$RX_LM"'\([0-9]\{2\}\)';


    RX_USGSID='[A-Z]\{2\}[0-9]\{2\}';
    RX_PATHROW='[0-9]\{3\}[0-9]\{3\}';
    RX_LAT='[NS][0-9]\{2\}_[0-9]\{6\}';
    RX_LON='[EW][0-9]\{3\}_[0-9]\{6\}';

    sed -e "s:.*/${RX_USGSID}${RX_PATHROW}${RX_YMD}.*:jan 1 \1 - 1 month - 1 days + \2 months \3 days:g" \
        -e "s:.*/${RX_USGSID}${RX_LAT}${RX_LON}${RX_YMD}.*:jan 1 \1 - 1 month - 1 days + \2 months \3 days:g" \
        -e "s:.*/AST_L1[AB]E_[0-9]\{3\}_${RX_MDY}${RX_PATHROW}_${RX_MDY}.*:jan 1 \6 - 1 month - 1 days + \4 months \5 days:g" \
        -e "s:.*/AST_L1B_[0-9]\{3\}${RX_MDY}.*:jan 1 \3 - 1 month - 1 days + \1 months \2 days:g" \
        -e "s:.*/.*[.][A-Z]${RX_YDJ}[.].*:jan 1 \1 \2 days - 1 day:g" \
        -e "s:.*/${RX_MLD}.*:\1 \2:g" \
        -e "s:.*/.*[.]${RX_YDJ}[.]\(aqua\|terra\).*:jan 1 \1 \2 days - 1 day:g" \
        -e "s:.*[/=]EO1[AH]${RX_PATHROW}${RX_YDJ}.*:jan 1 \1 \2 days - 1 day:g" \
        -e "s:.*[/=]LT[0-9]${RX_PATHROW}${RX_YDJ}.*:jan 1 \1 \2 days - 1 day:g" \
        -e "s:.*[/=]LE[0-9]${RX_PATHROW}${RX_YDJ}.*:jan 1 \1 \2 days - 1 day:g" \
     | date -f /dev/stdin "+%Y%m%d" | sed 's:^get.*::g'
}

###############################################################################
## @brief function to get the a list of new files
##
## @param mirrorfile    file to store the lftp commands in
## @param pattern       include pattern to search for on the site
##
## @return 0 for true

###############################################################################

getlist () {
    local mirrorfile="$1"
    local pattern="$2"
    #FIXME use locals
    #FIXME check for errors
    #FIXME do the pattern matching stuff in awk
    
    ##### get the list of files on the site #####
    
    mirrorscript="$(lftp "$baseurl" -e "mirror --just-print ; exit")"
    
    ##### if pattern is set get a list of those files #####

    local regex="${pattern//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//\?/.}"
    
    if [ -n "$pattern" ] 
    then
        if grep -i -e "$regex" <<<"$mirrorscript" > /dev/null
        then
            local files="$(grep -i -e "$regex" <<<"$mirrorscript")"
        else
            return
        fi
    
    ##### tif #####
    
    elif grep -i -e "[.]tif$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tif$" <<<"$mirrorscript")"

    ##### zip #####
    
    elif grep -i -e "[.]zip$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]zip$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar.gz #####
    
    elif grep -i -e "[.]tar.gz$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar.gz$" <<<"$mirrorscript")"
        local isarchive="yes"
        
        
    ##### tgz #####
    
    elif grep -i -e "[.]tgz$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tgz$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar.bz2 #####
    
    elif grep -i -e "[.]tar.bz2$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar.bz2$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar #####
    
    elif grep -i -e "[.]tar$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### jpeg2000 #####
    
    elif grep -i -e "[.]jp2$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]jp2$" <<<"$mirrorscript")"
    
    ##### png #####
    
    elif grep -i -e "[.]png$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]png$" <<<"$mirrorscript")"
    
    ##### jpg #####
    
    elif grep -i -e "[.]jpg$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]jpg$" <<<"$mirrorscript")"
    
    ##### gif #####
    
    elif grep -i -e "[.]gif$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]gif$" <<<"$mirrorscript")"
    
    ##### no match, bail #####
    
    else
        return
    fi
    
    ##### add the mkdir commands to the mirrorfile first #####
    
    grep -e "^mkdir" <<<"$mirrorscript" > "$mirrorfile"
    
    ##### loop over the list of files to fetch #####
    
    local line
    while read line 
    do
    
        local file="${line##*/}"

        local base="${file%.*}"
        local base2="${base%.*}"
        local ext="${file##*.}"
        if [[ "$isarchive" = "yes" ]]
        then
            echo "$line"
        else
            
            ##### test for world and aux files #####

            local world="$(grep -i -e "${sdir}${base}[.]..w$" <<<"$mirrorscript" | head -n 1)"
            local aux="$(grep -i -e "${sdir}${base}[.]aux$" <<<"$mirrorscript" | head -n 1)"
            local auxxml="$(grep -i -e "${sdir}${base}[.]aux.xml$" <<<"$mirrorscript" | head -n 1)"
        
            if [ -n "$world" ]
            then
                echo -n "$world ; "
            fi
            
            if [ -n "$aux" ]
            then
                echo -n "$aux ; "
            fi
            
            if [ -n "$auxxml" ]
            then
                echo -n "$auxxml ; "
            fi
            
            echo "$line"
        fi >> "$mirrorfile"
        
    done <<<"$files"
            
    
}

################################################################################
## @brief function to get the geotransform
##
## @param   image   full path to the image file
##
## @return 0 on success 1 on failure
## @retval stdout the geotransform "xo xd xr yo yr yd"
##
## @details
## read xo xd xr yo yr yd < <(get_transform "myfile.tif")
##
################################################################################

get_transform () {
    local infile="$1"
    local xo
    local xd
    local xr
    local yo
    local yr
    local yd

    local tmpdir
    tmpdir=$(mktemp -d -p "${tmp}" "${dsname}XXXXXXXXXX") || return


    gdalbuildvrt -overwrite \
                "${tmpdir}/testy.vrt" \
                "$infile" > /dev/null || return

    read xo xd xr yo yr yd < <(grep GeoTransform "${tmpdir}/testy.vrt" | sed -r 's/<.?GeoTransform>//g' | sed 's/,//g')
    xo=$(fsci2dec "$xo")
    xd=$(fsci2dec "$xd")
    xr=$(fsci2dec "$xr")
    yo=$(fsci2dec "$yo")
    yd=$(fsci2dec "$yd")
    yr=$(fsci2dec "$yr")

    rm -r "$tmpdir"

    echo $xo $xd $xr $yo $yr $yd

}

###############################################################################
## @brief function to get the size of an image
##
## @param   image   full path to the image file
## @param   info    cached gdalinfo string
##
## @return 0 on success 1 on failure
## @retval stdout the size of the image "x y"
##
###############################################################################

get_size () {
    local img="$1"
    local info="$2"
    
    if [[ -n "$info" ]]
    then
        grep -e "Size is" <<< "$info"
    else
        gdalinfo "$img" |\
         grep -e "Size is"
    fi |\
     sed 's/Size is \([0-9]*\), \([0-9]*\)/\1 \2/'

}

###############################################################################
## @brief function to get the pixel size
##
## @param   image   full path to the image file
##
## @return 0 on success 1 on failure
## @retval stdout the pixel size "dx dy"
##
###############################################################################

get_pixelsize() {

    gdalinfo "$1" | 
     grep -e "Pixel Size" |\
     sed 's/.*Pixel Size = (\([-.0-9]*\),\([-.0-9]*\)).*/\1 \2/'
}

###############################################################################
## @brief function to get the origin
##
## @param   image   full path to the image file
##
## @return 0 on success 1 on failure
## @retval stdout the origin of the image
##
###############################################################################

get_origin () {

    gdalinfo "$1" | \
     grep -e "Origin" |\
     sed 's/.*Origin = (*\([-.0-9]*\),*\([-.0-9]*\)).*/\1 \2/'
}

###############################################################################
## @brief function to get the number of bands
##
## @param   image   full path to the image file
##
## @return 0 on success 1 on failure
## @retval stdout the number of bands
##
###############################################################################

get_num_bands () {
    gdalinfo "$1" |\
     grep "^Band " |\
     wc -l
}

###############################################################################
## @brief function to get a bands type
##
## @param image     full path to the image file
## @param band      band number  
## @return 0 on success 1 on failure
## @retval stdout the type
##
###############################################################################

get_band_type () {
    gdalinfo "$1" |\
     grep "^Band $2 " |\
     grep "Type=" |\
     sed 's/.*Type=\(\w*\).*/\1/' |\
     head -n 1
}

###############################################################################
## @brief function to get a the srs of an image
##
## @param   image   full path to the image file
##
## @return 0 on success 1 on failure
## @retval stdout the srs
##
###############################################################################

get_srs () {
    gdalinfo "$1" |\
     sed -n '/PROJCS\|GEOGCS/,${//p;/^   /p;}' |\
     uniq |\
     tr "\n" " " |\
     sed -e 's/[ ]*//g' \
         -e 's/"/&quot;/'
}

get_minmax () {
    local img="$1"
    local band="$2"

    gdalinfo -mm "$img" |\
     grep -A1 "^Band $band" |\
     grep "Min/Max" |\
     sed 's|.*Min/Max=\([-.0-9]*\),\([-.0-9]*\).*|\1 \2|'

}

###############################################################################
## @brief an array of gdal types
###############################################################################

GDAL_TYPES=( Byte UInt16 Int16 UInt32 Int32 Float32 Float64);

###############################################################################
## @brief encode a url
##
## @param url   url to parse
##
## @return 0 on success
## @retval stdout the encoded url
##
###############################################################################

url_encode () {
    if ! [ -n "$1" ]
    then
        return 1
    fi

    local encodedurl="$1";
    
    hexdump -v -e '1/1 "%02x\t"' -e '1/1 "%_c\n"' <<<"$encodedurl" |\
     url_encode_awk
    
    ##### needs A NEWLINE #####
    
    echo

}

url_encode_awk () {
    LANG=C awk '
$1 == "20"                    { printf("%s",   "+"); next } # space becomes plus
$1 ~  /0[adAD]/               {                      next } # strip newlines
$2 ~  /^[a-zA-Z0-9.*()\/-]$/  { printf("%s",   $2);  next } # pass through what we can
                              { printf("%%%s", $1)        } # take hex value of everything else
'
}

###############################################################################
## @brief function to get the query part of a url
##
## @param url   url to parse
##
## @return 0 on success
## @retval stdout the query
##
###############################################################################

url_get_query () {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    url="${url#*\?}"
    if [[ "$url" != "$1" ]]
    then
        url="${url%%\#*}"
        echo "?$url"
    fi
    
}
    
###############################################################################
## @brief function to get the hash part of a url
##
## @param url   url to parse
##
## @return 0 on success
## @retval stdout the hash
##
###############################################################################

url_get_hash () {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    url="${url#*\#}"
    if [[ "$url" != "$1" ]]
    then
        echo "#$url"
    fi
    
}

###############################################################################
## @brief function to get the path part of a url
##
## @param url   url to parse
##
## @return 0 on success
## @retval stdout the path
##
###############################################################################

url_get_path () {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    
    url="${url/*:\/\//}"
    url="/${url#*/}"
    url="${url%%\#*}"
    url="${url%%\?*}"
    
    echo "$url"
    
}

###############################################################################
## @brief function to get the host part of a url
##
## @param url   url to parse
##
## @return 0 on success
## @retval stdout the host
##
###############################################################################

url_get_host () {

    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    
    url="${url/*:??/}"
    url="${url#*@}"
    url="${url%%/*}"
    
    echo "$url"
    
}

###############################################################################
## @brief function to get the proto part of a url
##
## @param url   url to parse
##
## @return 0 on success
## @retval stdout the proto
##
###############################################################################

url_get_proto () {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    
    url="${url%%://*}"

    echo "$url"
    
}

###############################################################################
## @brief function to test if a value is un an array
##
## @param val       value to test
## @param array     the array
##
## @return 0  on true 1 on false
##
###############################################################################

isinarray () {
    local val="$1"
    local result=1
    shift
    
    local elem
    for elem;
    do
        if [[ "$val" = "$elem" ]]
        then
            result=0
            break;
        fi
    done
    
    return $result
}

###############################################################################
## @brief function to get the basename of a file
##
## @param input     pathname to parse
##
## @return 0 on success
## @retval stdout the basename
##
###############################################################################

file_get_basename () {
    local input="$1"
    
    local file="${input##*/}"
    
    local base="${file%.*}"
    local base2="${base%.*}"
    local ext="${file##*.}"
    local ext2="${base##*.}"
    local ext=$(tr "[A-Z]" "[a-z]" <<< "$ext")
    local ext2=$(tr "[A-Z]" "[a-z]" <<< "$ext2")

    if [[ "$ext2" == "tar" ]]
    then
        ext="${ext2}.${ext}"
        base="$base2"
    fi
    
    echo "$base"
    
}

###############################################################################
## @brief function to get the extension of a file
##
## @param input     pathname to parse
##
## @return 0 on success
## @retval stdout the extension
##
###############################################################################

file_get_extension () {
    local input="$1"
    
    local file="${input##*/}"
    
    local base="${file%.*}"
    local base2="${base%.*}"
    local ext="${file##*.}"
    local ext2="${base##*.}"
    local ext=$( tr "[A-Z]" "[a-z]" <<< "$ext")
    local ext2=$(tr "[A-Z]" "[a-z]" <<< "$ext2")

    if [[ "$ext2" == "tar" ]]
    then
        ext="${ext2}.${ext}"
        base="$base2"
    fi
    
    echo "$ext"
    
}

###############################################################################
## @brief function to get the dir of a file
##
## @param input     pathname to parse
##
## @return 0 on success
## @retval stdout the dir
##
###############################################################################

file_get_dir () {
    local input="$1"
    
    local dir="${input%/*}"
    if [[ "$dir" != "$input" ]]
    then
        echo "${dir}/"
    fi
    
}

###############################################################################
## @brief function to find a band file in an array of files
##
## @param msb       band to match
## @param files     array of files 
##
## @return 0 on success 1 on failure
## @retval stdout the matching file
##
###############################################################################

find_band_file () {
    local msb="$1"
    local files=("${@:2}")
    
    local f
    for f in "${files[@]}"
    do
        if [[ "$f" = *$msb* ]]
        then
            echo "$f"
            return 0
        fi
    done
    
    return 1
}

###############################################################################
## @brief function to find a band file in a dir
## 
## @param base  basename of the bands
## @param msb   band to match
## @param dir   dir to match files in
##
## @return 0 on success 1 on failure
## @retval stdout the matching file
##
###############################################################################

findmatchingfile () {
    local base="$1"
    local msb="$2"
    local dir="$3"
    
    local result=0
    
    shopt -s nullglob dotglob
    local file=( ${dir}/${base}*${msb}* )
    if (( ${#file[@]} ))
    then
        echo "${file[0]}"
    else
        result=1
    fi
    
    shopt -u nullglob dotglob
    
    return $result
}
